define(["./Transforms-827ad0a7","./Matrix2-7a8e9daf","./Matrix3-b2351961","./defaultValue-f6d5e6da","./Math-355606c6","./ArcType-26a3f38d","./arrayRemoveDuplicates-0d8dde26","./ComponentDatatype-ab629b88","./EllipsoidGeodesic-20aaff03","./EllipsoidRhumbLine-1289f7e8","./EncodedCartesian3-abad5e8c","./GeometryAttribute-00d7b8dc","./IntersectionTests-ccb1bd0f","./Plane-5931b53e","./WebMercatorProjection-db7467f4","./combine-0c102d93","./RuntimeError-9b4ce3fb","./WebGLConstants-7f557f93"],(function(e,t,n,a,i,r,s,o,l,c,u,C,h,d,p,f,g,m){"use strict";function w(i){i=a.defaultValue(i,a.defaultValue.EMPTY_OBJECT),this._ellipsoid=a.defaultValue(i.ellipsoid,n.Ellipsoid.WGS84),this._rectangle=a.defaultValue(i.rectangle,t.Rectangle.MAX_VALUE),this._projection=new e.GeographicProjection(this._ellipsoid),this._numberOfLevelZeroTilesX=a.defaultValue(i.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=a.defaultValue(i.numberOfLevelZeroTilesY,1),a.defined(i.tileInfo)&&(this._tileInfo=i.tileInfo)}Object.defineProperties(w.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),w.prototype.getNumberOfXTilesAtLevel=function(e){if(a.defined(this._tileInfo)){let t=this._tileInfo.lods.find((function(t){return t.level===e})).resolution;return Math.ceil(i.CesiumMath.toDegrees(this._rectangle.width)/(this._tileInfo.rows*t))}return this._numberOfLevelZeroTilesX<<e},w.prototype.getNumberOfYTilesAtLevel=function(e){if(a.defined(this._tileInfo)){let t=this._tileInfo.lods.find((function(t){return t.level===e})).resolution;return Math.ceil(i.CesiumMath.toDegrees(this._rectangle.height)/(this._tileInfo.cols*t))}return this._numberOfLevelZeroTilesY<<e},w.prototype.rectangleToNativeRectangle=function(e,n){const r=i.CesiumMath.toDegrees(e.west),s=i.CesiumMath.toDegrees(e.south),o=i.CesiumMath.toDegrees(e.east),l=i.CesiumMath.toDegrees(e.north);return a.defined(n)?(n.west=r,n.south=s,n.east=o,n.north=l,n):new t.Rectangle(r,s,o,l)},w.prototype.tileXYToNativeRectangle=function(e,t,n,a){const r=this.tileXYToRectangle(e,t,n,a);return r.west=i.CesiumMath.toDegrees(r.west),r.south=i.CesiumMath.toDegrees(r.south),r.east=i.CesiumMath.toDegrees(r.east),r.north=i.CesiumMath.toDegrees(r.north),r},w.prototype.tileXYToRectangle=function(e,n,r,s){const o=this._rectangle;let l,c;if(a.defined(this._tileInfo)){let e=this._tileInfo.lods.find((function(e){return e.level===r}));l=i.CesiumMath.toRadians(e.resolution*this._tileInfo.rows),c=i.CesiumMath.toRadians(e.resolution*this._tileInfo.cols)}else{const e=this.getNumberOfXTilesAtLevel(r),t=this.getNumberOfYTilesAtLevel(r);l=o.width/e,c=o.height/t}const u=e*l+o.west,C=(e+1)*l+o.west,h=o.north-n*c,d=o.north-(n+1)*c;return a.defined(s)||(s=new t.Rectangle(u,d,C,h)),s.west=u,s.south=d,s.east=C,s.north=h,s},w.prototype.positionToTileXY=function(e,n,r){const s=this._rectangle;if(!t.Rectangle.contains(s,e))return;let o,l;const c=this.getNumberOfXTilesAtLevel(n),u=this.getNumberOfYTilesAtLevel(n);if(a.defined(this._tileInfo)){let e=this._tileInfo.lods.find((function(e){return e.level===n}));o=i.CesiumMath.toRadians(e.resolution*this._tileInfo.rows),l=i.CesiumMath.toRadians(e.resolution*this._tileInfo.cols)}else o=s.width/c,l=s.height/u;let C=e.longitude;s.east<s.west&&(C+=i.CesiumMath.TWO_PI);let h=(C-s.west)/o|0;h>=c&&(h=c-1);let d=(s.north-e.latitude)/l|0;return d>=u&&(d=u-1),a.defined(r)?(r.x=h,r.y=d,r):new t.Cartesian2(h,d)};const y=new n.Cartesian3,M=new n.Cartesian3,_=new n.Cartographic,T=new n.Cartesian3,E=new n.Cartesian3,O=new e.BoundingSphere,I=new w,P=[new n.Cartographic,new n.Cartographic,new n.Cartographic,new n.Cartographic],A=new t.Cartesian2,b={};function k(e){n.Cartographic.fromRadians(e.east,e.north,0,P[0]),n.Cartographic.fromRadians(e.west,e.north,0,P[1]),n.Cartographic.fromRadians(e.east,e.south,0,P[2]),n.Cartographic.fromRadians(e.west,e.south,0,P[3]);let t=0,a=0,i=0,r=0;const s=b._terrainHeightsMaxLevel;let o;for(o=0;o<=s;++o){let e=!1;for(let t=0;t<4;++t){const n=P[t];if(I.positionToTileXY(n,o,A),0===t)i=A.x,r=A.y;else if(i!==A.x||r!==A.y){e=!0;break}}if(e)break;t=i,a=r}if(0!==o)return{x:t,y:a,level:o>s?s:o-1}}b.initialize=function(){let t=b._initPromise;return a.defined(t)||(t=e.Resource.fetchJson(e.buildModuleUrl("Assets/approximateTerrainHeights.json")).then((function(e){b._terrainHeights=e})),b._initPromise=t),t},b.getMinimumMaximumHeights=function(e,i){i=a.defaultValue(i,n.Ellipsoid.WGS84);const r=k(e);let s=b._defaultMinTerrainHeight,o=b._defaultMaxTerrainHeight;if(a.defined(r)){const l=`${r.level}-${r.x}-${r.y}`,c=b._terrainHeights[l];a.defined(c)&&(s=c[0],o=c[1]),i.cartographicToCartesian(t.Rectangle.northeast(e,_),y),i.cartographicToCartesian(t.Rectangle.southwest(e,_),M),n.Cartesian3.midpoint(M,y,T);const u=i.scaleToGeodeticSurface(T,E);if(a.defined(u)){const e=n.Cartesian3.distance(T,u);s=Math.min(s,-e)}else s=b._defaultMinTerrainHeight}return s=Math.max(b._defaultMinTerrainHeight,s),{minimumTerrainHeight:s,maximumTerrainHeight:o}},b.getBoundingSphere=function(t,i){i=a.defaultValue(i,n.Ellipsoid.WGS84);const r=k(t);let s=b._defaultMaxTerrainHeight;if(a.defined(r)){const e=`${r.level}-${r.x}-${r.y}`,t=b._terrainHeights[e];a.defined(t)&&(s=t[1])}const o=e.BoundingSphere.fromRectangle3D(t,i,0);return e.BoundingSphere.fromRectangle3D(t,i,s,O),e.BoundingSphere.union(o,O,o)},b._terrainHeightsMaxLevel=6,b._defaultMaxTerrainHeight=9e3,b._defaultMinTerrainHeight=-1e5,b._terrainHeights=void 0,b._initPromise=void 0,Object.defineProperties(b,{initialized:{get:function(){return a.defined(b._terrainHeights)}}});var L=b;const S=[e.GeographicProjection,p.WebMercatorProjection],x=S.length,R=Math.cos(i.CesiumMath.toRadians(30)),N=Math.cos(i.CesiumMath.toRadians(150)),D=0,v=1e3;function z(e){const t=(e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT)).positions;this.width=a.defaultValue(e.width,1),this._positions=t,this.granularity=a.defaultValue(e.granularity,9999),this.loop=a.defaultValue(e.loop,!1),this.arcType=a.defaultValue(e.arcType,r.ArcType.GEODESIC),this._ellipsoid=n.Ellipsoid.WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(z.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+n.Ellipsoid.packedLength+1+1}}}),z.setProjectionAndEllipsoid=function(e,t){let n=0;for(let e=0;e<x;e++)if(t instanceof S[e]){n=e;break}e._projectionIndex=n,e._ellipsoid=t.ellipsoid};const H=new n.Cartesian3,j=new n.Cartesian3,B=new n.Cartesian3;function V(e,t,a,i,r){const s=U(i,e,0,H),o=U(i,e,a,j),l=U(i,t,0,B),c=Z(o,s,j),u=Z(l,s,B);return n.Cartesian3.cross(u,c,r),n.Cartesian3.normalize(r,r)}const G=new n.Cartographic,Y=new n.Cartesian3,F=new n.Cartesian3,q=new n.Cartesian3;function X(e,t,a,i,s,o,u,C,h,d,p){if(0===s)return;let f;o===r.ArcType.GEODESIC?f=new l.EllipsoidGeodesic(e,t,u):o===r.ArcType.RHUMB&&(f=new c.EllipsoidRhumbLine(e,t,u));const g=f.surfaceDistance;if(g<s)return;const m=V(e,t,i,u,q),w=Math.ceil(g/s),y=g/w;let M=y;const _=w-1;let T=C.length;for(let e=0;e<_;e++){const e=f.interpolateUsingSurfaceDistance(M,G),t=U(u,e,a,Y),r=U(u,e,i,F);n.Cartesian3.pack(m,C,T),n.Cartesian3.pack(t,h,T),n.Cartesian3.pack(r,d,T),p.push(e.latitude),p.push(e.longitude),T+=3,M+=y}}const W=new n.Cartographic;function U(e,t,a,i){return n.Cartographic.clone(t,W),W.height=a,n.Cartographic.toCartesian(W,e,i)}function Z(e,t,a){return n.Cartesian3.subtract(e,t,a),n.Cartesian3.normalize(a,a),a}function $(e,t,a,i){return i=Z(e,t,i),i=n.Cartesian3.cross(i,a,i),i=n.Cartesian3.normalize(i,i),i=n.Cartesian3.cross(a,i,i)}z.pack=function(e,t,i){let r=a.defaultValue(i,0);const s=e._positions,o=s.length;t[r++]=o;for(let e=0;e<o;++e){const a=s[e];n.Cartesian3.pack(a,t,r),r+=3}return t[r++]=e.granularity,t[r++]=e.loop?1:0,t[r++]=e.arcType,n.Ellipsoid.pack(e._ellipsoid,t,r),r+=n.Ellipsoid.packedLength,t[r++]=e._projectionIndex,t[r++]=e._scene3DOnly?1:0,t},z.unpack=function(e,t,i){let r=a.defaultValue(t,0);const s=e[r++],o=new Array(s);for(let t=0;t<s;t++)o[t]=n.Cartesian3.unpack(e,r),r+=3;const l=e[r++],c=1===e[r++],u=e[r++],C=n.Ellipsoid.unpack(e,r);r+=n.Ellipsoid.packedLength;const h=e[r++],d=1===e[r++];return a.defined(i)||(i=new z({positions:o})),i._positions=o,i.granularity=l,i.loop=c,i.arcType=u,i._ellipsoid=C,i._projectionIndex=h,i._scene3DOnly=d,i};const J=new n.Cartesian3,Q=new n.Cartesian3,K=new n.Cartesian3,ee=new n.Cartesian3;function te(e,t,a,r,s){const o=Z(a,t,ee),l=$(e,t,o,J),c=$(r,t,o,Q);if(i.CesiumMath.equalsEpsilon(n.Cartesian3.dot(l,c),-1,i.CesiumMath.EPSILON5))return s=n.Cartesian3.cross(o,l,s),s=n.Cartesian3.normalize(s,s);s=n.Cartesian3.add(c,l,s),s=n.Cartesian3.normalize(s,s);const u=n.Cartesian3.cross(o,s,K);return n.Cartesian3.dot(c,u)<0&&(s=n.Cartesian3.negate(s,s)),s}const ne=d.Plane.fromPointNormal(n.Cartesian3.ZERO,n.Cartesian3.UNIT_Y),ae=new n.Cartesian3,ie=new n.Cartesian3,re=new n.Cartesian3,se=new n.Cartesian3,oe=new n.Cartesian3,le=new n.Cartesian3,ce=new n.Cartographic,ue=new n.Cartographic,Ce=new n.Cartographic;z.createGeometry=function(l){const d=!l._scene3DOnly;let p=l.loop;const f=l._ellipsoid,g=l.granularity,m=l.arcType,w=new S[l._projectionIndex](f),y=D,M=v;let _,T;const E=l._positions,O=E.length;let I,P,A,b;2===O&&(p=!1);const k=new c.EllipsoidRhumbLine(void 0,void 0,f);let x,N,z;const H=[E[0]];for(T=0;T<O-1;T++)I=E[T],P=E[T+1],x=h.IntersectionTests.lineSegmentPlane(I,P,ne,le),!a.defined(x)||n.Cartesian3.equalsEpsilon(x,I,i.CesiumMath.EPSILON7)||n.Cartesian3.equalsEpsilon(x,P,i.CesiumMath.EPSILON7)||(l.arcType===r.ArcType.GEODESIC?H.push(n.Cartesian3.clone(x)):l.arcType===r.ArcType.RHUMB&&(z=f.cartesianToCartographic(x,ce).longitude,A=f.cartesianToCartographic(I,ce),b=f.cartesianToCartographic(P,ue),k.setEndPoints(A,b),N=k.findIntersectionWithLongitude(z,Ce),x=f.cartographicToCartesian(N,le),!a.defined(x)||n.Cartesian3.equalsEpsilon(x,I,i.CesiumMath.EPSILON7)||n.Cartesian3.equalsEpsilon(x,P,i.CesiumMath.EPSILON7)||H.push(n.Cartesian3.clone(x)))),H.push(P);p&&(I=E[O-1],P=E[0],x=h.IntersectionTests.lineSegmentPlane(I,P,ne,le),!a.defined(x)||n.Cartesian3.equalsEpsilon(x,I,i.CesiumMath.EPSILON7)||n.Cartesian3.equalsEpsilon(x,P,i.CesiumMath.EPSILON7)||(l.arcType===r.ArcType.GEODESIC?H.push(n.Cartesian3.clone(x)):l.arcType===r.ArcType.RHUMB&&(z=f.cartesianToCartographic(x,ce).longitude,A=f.cartesianToCartographic(I,ce),b=f.cartesianToCartographic(P,ue),k.setEndPoints(A,b),N=k.findIntersectionWithLongitude(z,Ce),x=f.cartographicToCartesian(N,le),!a.defined(x)||n.Cartesian3.equalsEpsilon(x,I,i.CesiumMath.EPSILON7)||n.Cartesian3.equalsEpsilon(x,P,i.CesiumMath.EPSILON7)||H.push(n.Cartesian3.clone(x)))));let j=H.length,B=new Array(j);for(T=0;T<j;T++){const e=n.Cartographic.fromCartesian(H[T],f);e.height=0,B[T]=e}if(B=s.arrayRemoveDuplicates(B,n.Cartographic.equalsEpsilon),j=B.length,j<2)return;const G=[],Y=[],F=[],q=[];let W=ae,$=ie,J=re,Q=se,K=oe;const ee=B[0],he=B[1];for(W=U(f,B[j-1],y,W),Q=U(f,he,y,Q),$=U(f,ee,y,$),J=U(f,ee,M,J),K=p?te(W,$,J,Q,K):V(ee,he,M,f,K),n.Cartesian3.pack(K,Y,0),n.Cartesian3.pack($,F,0),n.Cartesian3.pack(J,q,0),G.push(ee.latitude),G.push(ee.longitude),X(ee,he,y,M,g,m,f,Y,F,q,G),T=1;T<j-1;++T){W=n.Cartesian3.clone($,W),$=n.Cartesian3.clone(Q,$);const e=B[T];U(f,e,M,J),U(f,B[T+1],y,Q),te(W,$,J,Q,K),_=Y.length,n.Cartesian3.pack(K,Y,_),n.Cartesian3.pack($,F,_),n.Cartesian3.pack(J,q,_),G.push(e.latitude),G.push(e.longitude),X(B[T],B[T+1],y,M,g,m,f,Y,F,q,G)}const de=B[j-1],pe=B[j-2];if($=U(f,de,y,$),J=U(f,de,M,J),p){const e=B[0];W=U(f,pe,y,W),Q=U(f,e,y,Q),K=te(W,$,J,Q,K)}else K=V(pe,de,M,f,K);if(_=Y.length,n.Cartesian3.pack(K,Y,_),n.Cartesian3.pack($,F,_),n.Cartesian3.pack(J,q,_),G.push(de.latitude),G.push(de.longitude),p){for(X(de,ee,y,M,g,m,f,Y,F,q,G),_=Y.length,T=0;T<3;++T)Y[_+T]=Y[T],F[_+T]=F[T],q[_+T]=q[T];G.push(ee.latitude),G.push(ee.longitude)}return function(a,r,s,l,c,h,d){let p,f;const g=r._ellipsoid,m=s.length/3-1,w=8*m,y=4*w,M=36*m,_=w>65535?new Uint32Array(M):new Uint16Array(M),T=new Float64Array(3*w),E=new Float32Array(y),O=new Float32Array(y),I=new Float32Array(y),P=new Float32Array(y),A=new Float32Array(y);let b,k,S,x;d&&(b=new Float32Array(y),k=new Float32Array(y),S=new Float32Array(y),x=new Float32Array(2*w));const N=h.length/2;let D=0;const v=Pe;v.height=0;const z=Ae;z.height=0;let H=be,j=ke;if(d)for(f=0,p=1;p<N;p++)v.latitude=h[f],v.longitude=h[f+1],z.latitude=h[f+2],z.longitude=h[f+3],H=r.project(v,H),j=r.project(z,j),D+=n.Cartesian3.distance(H,j),f+=2;const B=l.length/3;j=n.Cartesian3.unpack(l,0,j);let V,G=0;for(f=3,p=1;p<B;p++)H=n.Cartesian3.clone(j,H),j=n.Cartesian3.unpack(l,f,j),G+=n.Cartesian3.distance(H,j),f+=3;f=3;let Y=0,F=0,q=0,X=0,W=!1,U=n.Cartesian3.unpack(s,0,Se),$=n.Cartesian3.unpack(l,0,ke),J=n.Cartesian3.unpack(c,0,Re);if(a){fe(J,n.Cartesian3.unpack(s,s.length-6,Le),U,$)&&(J=n.Cartesian3.negate(J,J))}let Q=0,K=0,ee=0;for(p=0;p<m;p++){const e=n.Cartesian3.clone(U,Le),a=n.Cartesian3.clone($,be);let o,C,p,m,w=n.Cartesian3.clone(J,xe);if(W&&(w=n.Cartesian3.negate(w,w)),U=n.Cartesian3.unpack(s,f,Se),$=n.Cartesian3.unpack(l,f,ke),J=n.Cartesian3.unpack(c,f,Re),W=fe(J,e,U,$),v.latitude=h[Y],v.longitude=h[Y+1],z.latitude=h[Y+2],z.longitude=h[Y+3],d){const e=Ie(v,z);o=r.project(v,Be),C=r.project(z,Ve);const t=Z(C,o,Qe);t.y=Math.abs(t.y),p=Ge,m=Ye,0===e||n.Cartesian3.dot(t,n.Cartesian3.UNIT_Y)>R?(p=ye(r,v,w,o,Ge),m=ye(r,z,J,C,Ye)):1===e?(m=ye(r,z,J,C,Ye),p.x=0,p.y=i.CesiumMath.sign(v.longitude-Math.abs(z.longitude)),p.z=0):(p=ye(r,v,w,o,Ge),m.x=0,m.y=i.CesiumMath.sign(v.longitude-z.longitude),m.z=0)}const y=n.Cartesian3.distance(a,$),M=u.EncodedCartesian3.fromCartesian(e,$e),_=n.Cartesian3.subtract(U,e,Fe),N=n.Cartesian3.normalize(_,We);let H=n.Cartesian3.subtract(a,e,qe);H=n.Cartesian3.normalize(H,H);let j=n.Cartesian3.cross(N,H,We);j=n.Cartesian3.normalize(j,j);let B=n.Cartesian3.cross(H,w,Ue);B=n.Cartesian3.normalize(B,B);let te=n.Cartesian3.subtract($,U,Xe);te=n.Cartesian3.normalize(te,te);let ne=n.Cartesian3.cross(J,te,Ze);ne=n.Cartesian3.normalize(ne,ne);const ae=y/G,ie=Q/G;let re,se,oe,le=0,ce=0,ue=0;if(d){le=n.Cartesian3.distance(o,C),re=u.EncodedCartesian3.fromCartesian(o,Je),se=n.Cartesian3.subtract(C,o,Qe),oe=n.Cartesian3.normalize(se,Ke);const e=oe.x;oe.x=oe.y,oe.y=-e,ce=le/D,ue=K/D}for(V=0;V<8;V++){const e=X+4*V,t=F+2*V,a=e+3,i=V<4?1:-1,r=2===V||3===V||6===V||7===V?1:-1;n.Cartesian3.pack(M.high,E,e),E[a]=_.x,n.Cartesian3.pack(M.low,O,e),O[a]=_.y,n.Cartesian3.pack(B,I,e),I[a]=_.z,n.Cartesian3.pack(ne,P,e),P[a]=ae*i,n.Cartesian3.pack(j,A,e);let s=ie*r;0===s&&r<0&&(s=9),A[a]=s,d&&(b[e]=re.high.x,b[e+1]=re.high.y,b[e+2]=re.low.x,b[e+3]=re.low.y,S[e]=-p.y,S[e+1]=p.x,S[e+2]=m.y,S[e+3]=-m.x,k[e]=se.x,k[e+1]=se.y,k[e+2]=oe.x,k[e+3]=oe.y,x[t]=ce*i,s=ue*r,0===s&&r<0&&(s=9),x[t+1]=s)}const Ce=He,he=je,de=ve,pe=ze,ge=t.Rectangle.fromCartographicArray(Ne,De),me=L.getMinimumMaximumHeights(ge,g),we=me.minimumTerrainHeight,Me=me.maximumTerrainHeight;ee+=we,ee+=Me,Te(e,a,we,Me,Ce,de),Te(U,$,we,Me,he,pe);let _e=n.Cartesian3.multiplyByScalar(j,i.CesiumMath.EPSILON5,et);n.Cartesian3.add(Ce,_e,Ce),n.Cartesian3.add(he,_e,he),n.Cartesian3.add(de,_e,de),n.Cartesian3.add(pe,_e,pe),Oe(Ce,he),Oe(de,pe),n.Cartesian3.pack(Ce,T,q),n.Cartesian3.pack(he,T,q+3),n.Cartesian3.pack(pe,T,q+6),n.Cartesian3.pack(de,T,q+9),_e=n.Cartesian3.multiplyByScalar(j,-2*i.CesiumMath.EPSILON5,et),n.Cartesian3.add(Ce,_e,Ce),n.Cartesian3.add(he,_e,he),n.Cartesian3.add(de,_e,de),n.Cartesian3.add(pe,_e,pe),Oe(Ce,he),Oe(de,pe),n.Cartesian3.pack(Ce,T,q+12),n.Cartesian3.pack(he,T,q+15),n.Cartesian3.pack(pe,T,q+18),n.Cartesian3.pack(de,T,q+21),Y+=2,f+=3,F+=16,q+=24,X+=32,Q+=y,K+=le}f=0;let te=0;for(p=0;p<m;p++){for(V=0;V<at;V++)_[f+V]=nt[V]+te;te+=8,f+=at}const ne=tt;e.BoundingSphere.fromVertices(s,n.Cartesian3.ZERO,3,ne[0]),e.BoundingSphere.fromVertices(l,n.Cartesian3.ZERO,3,ne[1]);const ae=e.BoundingSphere.fromBoundingSpheres(ne);ae.radius+=ee/(2*m);const ie={position:new C.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,normalize:!1,values:T}),startHiAndForwardOffsetX:it(E),startLoAndForwardOffsetY:it(O),startNormalAndForwardOffsetZ:it(I),endNormalAndTextureCoordinateNormalizationX:it(P),rightNormalAndTextureCoordinateNormalizationY:it(A)};d&&(ie.startHiLo2D=it(b),ie.offsetAndRight2D=it(k),ie.startEndNormals2D=it(S),ie.texcoordNormalization2D=new C.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,normalize:!1,values:x}));return new C.Geometry({attributes:ie,indices:_,boundingSphere:ae})}(p,w,F,q,Y,G,d)};const he=new n.Cartesian3,de=new n.Matrix3,pe=new e.Quaternion;function fe(t,a,r,s){const o=Z(r,a,he),l=n.Cartesian3.dot(o,t);if(l>R||l<N){const a=Z(s,r,ee),o=l<N?i.CesiumMath.PI_OVER_TWO:-i.CesiumMath.PI_OVER_TWO,c=e.Quaternion.fromAxisAngle(a,o,pe),u=n.Matrix3.fromQuaternion(c,de);return n.Matrix3.multiplyByVector(u,t,t),!0}return!1}const ge=new n.Cartographic,me=new n.Cartesian3,we=new n.Cartesian3;function ye(e,t,a,r,s){const o=n.Cartographic.toCartesian(t,e._ellipsoid,me);let l=n.Cartesian3.add(o,a,we),c=!1;const u=e._ellipsoid;let C=u.cartesianToCartographic(l,ge);Math.abs(t.longitude-C.longitude)>i.CesiumMath.PI_OVER_TWO&&(c=!0,l=n.Cartesian3.subtract(o,a,we),C=u.cartesianToCartographic(l,ge)),C.height=0;const h=e.project(C,s);return(s=n.Cartesian3.subtract(h,r,s)).z=0,s=n.Cartesian3.normalize(s,s),c&&n.Cartesian3.negate(s,s),s}const Me=new n.Cartesian3,_e=new n.Cartesian3;function Te(e,t,a,i,r,s){const o=n.Cartesian3.subtract(t,e,Me);n.Cartesian3.normalize(o,o);const l=a-D;let c=n.Cartesian3.multiplyByScalar(o,l,_e);n.Cartesian3.add(e,c,r);const u=i-v;c=n.Cartesian3.multiplyByScalar(o,u,_e),n.Cartesian3.add(t,c,s)}const Ee=new n.Cartesian3;function Oe(e,t){const a=d.Plane.getPointDistance(ne,e),r=d.Plane.getPointDistance(ne,t);let s=Ee;i.CesiumMath.equalsEpsilon(a,0,i.CesiumMath.EPSILON2)?(s=Z(t,e,s),n.Cartesian3.multiplyByScalar(s,i.CesiumMath.EPSILON2,s),n.Cartesian3.add(e,s,e)):i.CesiumMath.equalsEpsilon(r,0,i.CesiumMath.EPSILON2)&&(s=Z(e,t,s),n.Cartesian3.multiplyByScalar(s,i.CesiumMath.EPSILON2,s),n.Cartesian3.add(t,s,t))}function Ie(e,t){const n=Math.abs(e.longitude),a=Math.abs(t.longitude);if(i.CesiumMath.equalsEpsilon(n,i.CesiumMath.PI,i.CesiumMath.EPSILON11)){const a=i.CesiumMath.sign(t.longitude);return e.longitude=a*(n-i.CesiumMath.EPSILON11),1}if(i.CesiumMath.equalsEpsilon(a,i.CesiumMath.PI,i.CesiumMath.EPSILON11)){const n=i.CesiumMath.sign(e.longitude);return t.longitude=n*(a-i.CesiumMath.EPSILON11),2}return 0}const Pe=new n.Cartographic,Ae=new n.Cartographic,be=new n.Cartesian3,ke=new n.Cartesian3,Le=new n.Cartesian3,Se=new n.Cartesian3,xe=new n.Cartesian3,Re=new n.Cartesian3,Ne=[Pe,Ae],De=new t.Rectangle,ve=new n.Cartesian3,ze=new n.Cartesian3,He=new n.Cartesian3,je=new n.Cartesian3,Be=new n.Cartesian3,Ve=new n.Cartesian3,Ge=new n.Cartesian3,Ye=new n.Cartesian3,Fe=new n.Cartesian3,qe=new n.Cartesian3,Xe=new n.Cartesian3,We=new n.Cartesian3,Ue=new n.Cartesian3,Ze=new n.Cartesian3,$e=new u.EncodedCartesian3,Je=new u.EncodedCartesian3,Qe=new n.Cartesian3,Ke=new n.Cartesian3,et=new n.Cartesian3,tt=[new e.BoundingSphere,new e.BoundingSphere],nt=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],at=nt.length;function it(e){return new C.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}return z._projectNormal=ye,function(e,t){return L.initialize().then((function(){return a.defined(t)&&(e=z.unpack(e,t)),z.createGeometry(e)}))}}));
